{
"name": "smart-expense-splitter-django",
"description": "Django web app (SQLite) for splitting expenses among friends. Includes REST endpoints to create groups, add members, add expenses, view balance report and settlement mapping.",
"language": "python",
"run": "pip install -r requirements.txt && python manage.py migrate && python manage.py runserver 0.0.0.0:3000",
"install": "pip install -r requirements.txt",
"files": {
"requirements.txt": "Django>=4.2\ndjangorestframework\n",
"manage.py": "#!/usr/bin/env python\nimport os\nimport sys\n\nif **name** == '**main**':\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'project.settings')\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            "Couldn't import Django. Are you sure it's installed and available on your PYTHONPATH?"\n        ) from exc\n    execute_from_command_line(sys.argv)\n",
"project/**init**.py": "",
"project/settings.py": "from pathlib import Path\n\nBASE_DIR = Path(**file**).resolve().parent.parent\nSECRET_KEY = 'dev-secret-for-replit'\nDEBUG = True\nALLOWED_HOSTS = ['*']\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'rest_framework',\n    'splitter',\n]\n\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\nROOT_URLCONF = 'project.urls'\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n\nWSGI_APPLICATION = 'project.wsgi.application'\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': BASE_DIR / 'db.sqlite3',\n    }\n}\n\nAUTH_PASSWORD_VALIDATORS = []\n\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_TZ = True\n\nSTATIC_URL = 'static/'\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n",
"project/urls.py": "from django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/', include('splitter.urls')),\n]\n",
"project/wsgi.py": "import os\nfrom django.core.wsgi import get_wsgi_application\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'project.settings')\napplication = get_wsgi_application()\n",
"splitter/**init**.py": "",
"splitter/apps.py": "from django.apps import AppConfig\n\nclass SplitterConfig(AppConfig):\n    default_auto_field = 'django.db.models.BigAutoField'\n    name = 'splitter'\n",
"splitter/models.py": "from django.db import models\nfrom django.contrib.auth import get_user_model\n\nUser = get_user_model()\n\nclass Group(models.Model):\n    name = models.CharField(max_length=200)\n    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_groups')\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    def **str**(self):\n        return self.name\n\nclass GroupMember(models.Model):\n    group = models.ForeignKey(Group, on_delete=models.CASCADE, related_name='members')\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = ('group', 'user')\n\n    def **str**(self):\n        return f"{self.user.username} in {self.group.name}"\n\nclass Expense(models.Model):\n    group = models.ForeignKey(Group, on_delete=models.CASCADE, related_name='expenses')\n    payer = models.ForeignKey(User, on_delete=models.CASCADE, related_name='paid_expenses')\n    amount = models.DecimalField(max_digits=10, decimal_places=2)\n    description = models.CharField(max_length=500, blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    # For simplicity we assume equal split among current group members at expense creation\n    def **str**(self):\n        return f"{self.payer.username} paid {self.amount} for {self.group.name}"\n",
"splitter/serializers.py": "from rest_framework import serializers\nfrom django.contrib.auth import get_user_model\nfrom .models import Group, GroupMember, Expense\n\nUser = get_user_model()\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n\nclass GroupSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Group\n        fields = ['id', 'name', 'created_by', 'created_at']\n\nclass GroupMemberSerializer(serializers.ModelSerializer):\n    user = UserSerializer(read_only=True)\n    user_id = serializers.IntegerField(write_only=True)\n\n    class Meta:\n        model = GroupMember\n        fields = ['id', 'group', 'user', 'user_id']\n\nclass ExpenseSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Expense\n        fields = ['id', 'group', 'payer', 'amount', 'description', 'created_at']\n",
"splitter/urls.py": "from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('groups/', views.GroupListCreate.as_view(), name='group-list-create'),\n    path('groups/[int:group_id](int:group_id)/members/', views.AddMemberView.as_view(), name='group-add-member'),\n    path('groups/[int:group_id](int:group_id)/expenses/', views.ExpenseListCreate.as_view(), name='expense-list-create'),\n    path('groups/[int:group_id](int:group_id)/report/', views.group_report, name='group-report'),\n]\n",
"splitter/views.py": "from rest_framework import generics, status\nfrom rest_framework.response import Response\nfrom rest_framework.decorators import api_view\nfrom django.contrib.auth import get_user_model\nfrom .models import Group, GroupMember, Expense\nfrom .serializers import GroupSerializer, GroupMemberSerializer, ExpenseSerializer\nfrom decimal import Decimal\n\nUser = get_user_model()\n\nclass GroupListCreate(generics.ListCreateAPIView):\n    queryset = Group.objects.all()\n    serializer_class = GroupSerializer\n\nclass AddMemberView(generics.CreateAPIView):\n    serializer_class = GroupMemberSerializer\n\n    def post(self, request, group_id):\n        group = Group.objects.get(pk=group_id)\n        user_id = request.data.get('user_id')\n        user = User.objects.get(pk=user_id)\n        gm, created = GroupMember.objects.get_or_create(group=group, user=user)\n        return Response({'id': gm.id, 'created': created})\n\nclass ExpenseListCreate(generics.ListCreateAPIView):\n    serializer_class = ExpenseSerializer\n\n    def get_queryset(self):\n        group_id = self.kwargs['group_id']\n        return Expense.objects.filter(group_id=group_id)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n@api_view(['GET'])\ndef group_report(request, group_id):\n    """\n    Returns JSON report with:\n    - per-person net balances (positive => should receive, negative => should pay)\n    - settlement mapping: list of payments (who pays whom and how much)\n\n    Algorithm:\n    1. Compute total paid per member.\n    2. Split equally among current group members (based on GroupMember entries).\n    3. Net = paid - share. Positive means creditor, negative means debtor.\n    4. Greedy settle: match largest creditor with largest debtor until all settled.\n    """\n    try:\n        group = Group.objects.get(pk=group_id)\n    except Group.DoesNotExist:\n        return Response({'error': 'Group not found'}, status=404)\n\n    members_qs = GroupMember.objects.filter(group=group).select_related('user')\n    members = [m.user for m in members_qs]\n    if not members:\n        return Response({'error': 'No members in group'}, status=400)\n\n    member_ids = [m.id for m in members]\n    name_by_id = {m.id: m.username for m in members}\n\n    # total paid per user\n    paid = {m.id: Decimal('0.00') for m in members}\n    expenses = Expense.objects.filter(group=group)\n    for e in expenses:\n        pid = e.payer.id\n        paid[pid] = paid.get(pid, Decimal('0.00')) + Decimal(e.amount)\n\n    # compute share per member (equal split)\n    total = sum(paid.values())\n    member_count = len(members)\n    if member_count == 0:\n        return Response({'error': 'No members to split among'}, status=400)\n    per_head = (total / member_count).quantize(Decimal('0.01'))\n\n    # net balance = paid - per_head\n    net = {m.id: (paid.get(m.id, Decimal('0.00')) - per_head).quantize(Decimal('0.01')) for m in members}\n\n    # prepare creditors and debtors lists\n    creditors = []  # (user_id, amount) amount >0\n    debtors = []    # (user_id, amount) amount >0 (abs value)\n    for uid, bal in net.items():\n        if bal > 0:\n            creditors.append([uid, bal])\n        elif bal < 0:\n            debtors.append([uid, -bal])\n\n    # sort creditors descending, debtors descending\n    creditors.sort(key=lambda x: x[1], reverse=True)\n    debtors.sort(key=lambda x: x[1], reverse=True)\n\n    settlements = []\n    i = j = 0\n    # greedy match\n    while i < len(debtors) and j < len(creditors):\n        debtor_id, debtor_amt = debtors[i]\n        creditor_id, creditor_amt = creditors[j]\n        pay_amt = min(debtor_amt, creditor_amt).quantize(Decimal('0.01'))\n        settlements.append({\n            'from': name_by_id[debtor_id],\n            'to': name_by_id[creditor_id],\n            'amount': str(pay_amt)\n        })\n        # subtract\n        debtors[i][1] = (debtors[i][1] - pay_amt).quantize(Decimal('0.01'))\n        creditors[j][1] = (creditors[j][1] - pay_amt).quantize(Decimal('0.01'))\n        if debtors[i][1] == 0:\n            i += 1\n        if creditors[j][1] == 0:\n            j += 1\n\n    # format balances for response\n    balances = []\n    for uid, bal in net.items():\n        sign = 'get' if bal > 0 else 'pay' if bal < 0 else 'settled'\n        balances.append({\n            'user': name_by_id[uid],\n            'balance': str(bal),\n            'status': sign\n        })\n\n    return Response({\n        'group': group.name,\n        'total': str(total.quantize(Decimal('0.01'))),\n        'per_head': str(per_head),\n        'balances': balances,\n        'settlements': settlements\n    })\n",
"splitter/admin.py": "from django.contrib import admin\nfrom .models import Group, GroupMember, Expense\n\nadmin.site.register(Group)\nadmin.site.register(GroupMember)\nadmin.site.register(Expense)\n",
"README.md": "# Smart Expense Splitter (Django + SQLite)\n\n## Quick start (on Replit)\n\n1. Install dependencies (Replit will usually run `pip install -r requirements.txt` automatically).\n2. Run migrations:\n\n`bash\npython manage.py migrate\n`\n\n3. (Optional) Create a superuser:\n\n`bash\npython manage.py createsuperuser\n`\n\n4. Run the development server:\n\n`bash\npython manage.py runserver 0.0.0.0:3000\n`\n\n## Endpoints (basic)\n\n- `POST /api/groups/` - create group (body: `{ \"name\": \"Goa Trip\", \"created_by\": <user_id> }`)\n- `POST /api/groups/<group_id>/members/` - add member (body: `{ \"user_id\": <user_id> }`)\n- `POST /api/groups/<group_id>/expenses/` - add expense (body: `{ \"payer\": <user_id>, \"amount\": \"900.00\", \"description\": \"hotel\" }`)\n- `GET /api/groups/<group_id>/report/` - get balances + settlement mapping\n\nThis starter implements the core split + settlement algorithm (equal split) and returns JSON mapping using a greedy algorithm.\n",
".replit": "run = "pip install -r requirements.txt && python manage.py migrate && python manage.py runserver 0.0.0.0:3000"\n"
},
"notes": "This JSON is a Replit-ready project manifest: it contains all files necessary to run a minimal Django app on SQLite. It implements equal-split logic and a greedy settlement algorithm in the `group_report` endpoint. You can expand features (per-expense split ratios, expense-level participants, authentication endpoints, web UI) as needed."
}
